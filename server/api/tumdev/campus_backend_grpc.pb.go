// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: tumdev/campus_backend.proto

package api

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	NewsService_ListNewsAlerts_FullMethodName  = "/api.NewsService/ListNewsAlerts"
	NewsService_ListNewsSources_FullMethodName = "/api.NewsService/ListNewsSources"
	NewsService_ListNews_FullMethodName        = "/api.NewsService/ListNews"
)

// NewsServiceClient is the client API for NewsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NewsServiceClient interface {
	ListNewsAlerts(ctx context.Context, in *ListNewsAlertsRequest, opts ...grpc.CallOption) (*ListNewsAlertsReply, error)
	ListNewsSources(ctx context.Context, in *ListNewsSourcesRequest, opts ...grpc.CallOption) (*ListNewsSourcesReply, error)
	ListNews(ctx context.Context, in *ListNewsRequest, opts ...grpc.CallOption) (*ListNewsReply, error)
}

type newsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNewsServiceClient(cc grpc.ClientConnInterface) NewsServiceClient {
	return &newsServiceClient{cc}
}

func (c *newsServiceClient) ListNewsAlerts(ctx context.Context, in *ListNewsAlertsRequest, opts ...grpc.CallOption) (*ListNewsAlertsReply, error) {
	out := new(ListNewsAlertsReply)
	err := c.cc.Invoke(ctx, NewsService_ListNewsAlerts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newsServiceClient) ListNewsSources(ctx context.Context, in *ListNewsSourcesRequest, opts ...grpc.CallOption) (*ListNewsSourcesReply, error) {
	out := new(ListNewsSourcesReply)
	err := c.cc.Invoke(ctx, NewsService_ListNewsSources_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *newsServiceClient) ListNews(ctx context.Context, in *ListNewsRequest, opts ...grpc.CallOption) (*ListNewsReply, error) {
	out := new(ListNewsReply)
	err := c.cc.Invoke(ctx, NewsService_ListNews_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NewsServiceServer is the server API for NewsService service.
// All implementations must embed UnimplementedNewsServiceServer
// for forward compatibility
type NewsServiceServer interface {
	ListNewsAlerts(context.Context, *ListNewsAlertsRequest) (*ListNewsAlertsReply, error)
	ListNewsSources(context.Context, *ListNewsSourcesRequest) (*ListNewsSourcesReply, error)
	ListNews(context.Context, *ListNewsRequest) (*ListNewsReply, error)
	mustEmbedUnimplementedNewsServiceServer()
}

// UnimplementedNewsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNewsServiceServer struct {
}

func (UnimplementedNewsServiceServer) ListNewsAlerts(context.Context, *ListNewsAlertsRequest) (*ListNewsAlertsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNewsAlerts not implemented")
}
func (UnimplementedNewsServiceServer) ListNewsSources(context.Context, *ListNewsSourcesRequest) (*ListNewsSourcesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNewsSources not implemented")
}
func (UnimplementedNewsServiceServer) ListNews(context.Context, *ListNewsRequest) (*ListNewsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNews not implemented")
}
func (UnimplementedNewsServiceServer) mustEmbedUnimplementedNewsServiceServer() {}

// UnsafeNewsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NewsServiceServer will
// result in compilation errors.
type UnsafeNewsServiceServer interface {
	mustEmbedUnimplementedNewsServiceServer()
}

func RegisterNewsServiceServer(s grpc.ServiceRegistrar, srv NewsServiceServer) {
	s.RegisterService(&NewsService_ServiceDesc, srv)
}

func _NewsService_ListNewsAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNewsAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsServiceServer).ListNewsAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsService_ListNewsAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsServiceServer).ListNewsAlerts(ctx, req.(*ListNewsAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NewsService_ListNewsSources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNewsSourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsServiceServer).ListNewsSources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsService_ListNewsSources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsServiceServer).ListNewsSources(ctx, req.(*ListNewsSourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NewsService_ListNews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNewsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NewsServiceServer).ListNews(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NewsService_ListNews_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NewsServiceServer).ListNews(ctx, req.(*ListNewsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NewsService_ServiceDesc is the grpc.ServiceDesc for NewsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NewsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.NewsService",
	HandlerType: (*NewsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListNewsAlerts",
			Handler:    _NewsService_ListNewsAlerts_Handler,
		},
		{
			MethodName: "ListNewsSources",
			Handler:    _NewsService_ListNewsSources_Handler,
		},
		{
			MethodName: "ListNews",
			Handler:    _NewsService_ListNews_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tumdev/campus_backend.proto",
}

const (
	CampusService_GetUpdateNote_FullMethodName  = "/api.CampusService/GetUpdateNote"
	CampusService_ListMovies_FullMethodName     = "/api.CampusService/ListMovies"
	CampusService_CreateFeedback_FullMethodName = "/api.CampusService/CreateFeedback"
)

// CampusServiceClient is the client API for CampusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CampusServiceClient interface {
	GetUpdateNote(ctx context.Context, in *GetUpdateNoteRequest, opts ...grpc.CallOption) (*GetUpdateNoteReply, error)
	ListMovies(ctx context.Context, in *ListMoviesRequest, opts ...grpc.CallOption) (*ListMoviesReply, error)
	CreateFeedback(ctx context.Context, opts ...grpc.CallOption) (CampusService_CreateFeedbackClient, error)
}

type campusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCampusServiceClient(cc grpc.ClientConnInterface) CampusServiceClient {
	return &campusServiceClient{cc}
}

func (c *campusServiceClient) GetUpdateNote(ctx context.Context, in *GetUpdateNoteRequest, opts ...grpc.CallOption) (*GetUpdateNoteReply, error) {
	out := new(GetUpdateNoteReply)
	err := c.cc.Invoke(ctx, CampusService_GetUpdateNote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campusServiceClient) ListMovies(ctx context.Context, in *ListMoviesRequest, opts ...grpc.CallOption) (*ListMoviesReply, error) {
	out := new(ListMoviesReply)
	err := c.cc.Invoke(ctx, CampusService_ListMovies_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *campusServiceClient) CreateFeedback(ctx context.Context, opts ...grpc.CallOption) (CampusService_CreateFeedbackClient, error) {
	stream, err := c.cc.NewStream(ctx, &CampusService_ServiceDesc.Streams[0], CampusService_CreateFeedback_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &campusServiceCreateFeedbackClient{stream}
	return x, nil
}

type CampusService_CreateFeedbackClient interface {
	Send(*CreateFeedbackRequest) error
	CloseAndRecv() (*CreateFeedbackReply, error)
	grpc.ClientStream
}

type campusServiceCreateFeedbackClient struct {
	grpc.ClientStream
}

func (x *campusServiceCreateFeedbackClient) Send(m *CreateFeedbackRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *campusServiceCreateFeedbackClient) CloseAndRecv() (*CreateFeedbackReply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(CreateFeedbackReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CampusServiceServer is the server API for CampusService service.
// All implementations must embed UnimplementedCampusServiceServer
// for forward compatibility
type CampusServiceServer interface {
	GetUpdateNote(context.Context, *GetUpdateNoteRequest) (*GetUpdateNoteReply, error)
	ListMovies(context.Context, *ListMoviesRequest) (*ListMoviesReply, error)
	CreateFeedback(CampusService_CreateFeedbackServer) error
	mustEmbedUnimplementedCampusServiceServer()
}

// UnimplementedCampusServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCampusServiceServer struct {
}

func (UnimplementedCampusServiceServer) GetUpdateNote(context.Context, *GetUpdateNoteRequest) (*GetUpdateNoteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUpdateNote not implemented")
}
func (UnimplementedCampusServiceServer) ListMovies(context.Context, *ListMoviesRequest) (*ListMoviesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMovies not implemented")
}
func (UnimplementedCampusServiceServer) CreateFeedback(CampusService_CreateFeedbackServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateFeedback not implemented")
}
func (UnimplementedCampusServiceServer) mustEmbedUnimplementedCampusServiceServer() {}

// UnsafeCampusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CampusServiceServer will
// result in compilation errors.
type UnsafeCampusServiceServer interface {
	mustEmbedUnimplementedCampusServiceServer()
}

func RegisterCampusServiceServer(s grpc.ServiceRegistrar, srv CampusServiceServer) {
	s.RegisterService(&CampusService_ServiceDesc, srv)
}

func _CampusService_GetUpdateNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUpdateNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampusServiceServer).GetUpdateNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampusService_GetUpdateNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampusServiceServer).GetUpdateNote(ctx, req.(*GetUpdateNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampusService_ListMovies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMoviesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CampusServiceServer).ListMovies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CampusService_ListMovies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CampusServiceServer).ListMovies(ctx, req.(*ListMoviesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CampusService_CreateFeedback_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CampusServiceServer).CreateFeedback(&campusServiceCreateFeedbackServer{stream})
}

type CampusService_CreateFeedbackServer interface {
	SendAndClose(*CreateFeedbackReply) error
	Recv() (*CreateFeedbackRequest, error)
	grpc.ServerStream
}

type campusServiceCreateFeedbackServer struct {
	grpc.ServerStream
}

func (x *campusServiceCreateFeedbackServer) SendAndClose(m *CreateFeedbackReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *campusServiceCreateFeedbackServer) Recv() (*CreateFeedbackRequest, error) {
	m := new(CreateFeedbackRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CampusService_ServiceDesc is the grpc.ServiceDesc for CampusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CampusService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.CampusService",
	HandlerType: (*CampusServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUpdateNote",
			Handler:    _CampusService_GetUpdateNote_Handler,
		},
		{
			MethodName: "ListMovies",
			Handler:    _CampusService_ListMovies_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateFeedback",
			Handler:       _CampusService_CreateFeedback_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "tumdev/campus_backend.proto",
}

const (
	CanteenService_GetCanteenHeadCount_FullMethodName      = "/api.CanteenService/GetCanteenHeadCount"
	CanteenService_ListCanteenRatings_FullMethodName       = "/api.CanteenService/ListCanteenRatings"
	CanteenService_GetDishRatings_FullMethodName           = "/api.CanteenService/GetDishRatings"
	CanteenService_CreateCanteenRating_FullMethodName      = "/api.CanteenService/CreateCanteenRating"
	CanteenService_CreateDishRating_FullMethodName         = "/api.CanteenService/CreateDishRating"
	CanteenService_ListAvailableDishTags_FullMethodName    = "/api.CanteenService/ListAvailableDishTags"
	CanteenService_ListNameTags_FullMethodName             = "/api.CanteenService/ListNameTags"
	CanteenService_ListAvailableCanteenTags_FullMethodName = "/api.CanteenService/ListAvailableCanteenTags"
	CanteenService_ListCanteens_FullMethodName             = "/api.CanteenService/ListCanteens"
	CanteenService_ListDishes_FullMethodName               = "/api.CanteenService/ListDishes"
)

// CanteenServiceClient is the client API for CanteenService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CanteenServiceClient interface {
	GetCanteenHeadCount(ctx context.Context, in *GetCanteenHeadCountRequest, opts ...grpc.CallOption) (*GetCanteenHeadCountReply, error)
	// This endpoint retrieves Canteen Ratings from the Backend.
	ListCanteenRatings(ctx context.Context, in *ListCanteenRatingsRequest, opts ...grpc.CallOption) (*ListCanteenRatingsReply, error)
	GetDishRatings(ctx context.Context, in *GetDishRatingsRequest, opts ...grpc.CallOption) (*GetDishRatingsReply, error)
	CreateCanteenRating(ctx context.Context, in *CreateCanteenRatingRequest, opts ...grpc.CallOption) (*CreateCanteenRatingReply, error)
	CreateDishRating(ctx context.Context, in *CreateDishRatingRequest, opts ...grpc.CallOption) (*CreateDishRatingReply, error)
	ListAvailableDishTags(ctx context.Context, in *ListAvailableDishTagsRequest, opts ...grpc.CallOption) (*ListAvailableDishTagsReply, error)
	ListNameTags(ctx context.Context, in *ListNameTagsRequest, opts ...grpc.CallOption) (*ListNameTagsReply, error)
	ListAvailableCanteenTags(ctx context.Context, in *ListAvailableCanteenTagsRequest, opts ...grpc.CallOption) (*ListAvailableCanteenTagsReply, error)
	ListCanteens(ctx context.Context, in *ListCanteensRequest, opts ...grpc.CallOption) (*ListCanteensReply, error)
	ListDishes(ctx context.Context, in *ListDishesRequest, opts ...grpc.CallOption) (*ListDishesReply, error)
}

type canteenServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCanteenServiceClient(cc grpc.ClientConnInterface) CanteenServiceClient {
	return &canteenServiceClient{cc}
}

func (c *canteenServiceClient) GetCanteenHeadCount(ctx context.Context, in *GetCanteenHeadCountRequest, opts ...grpc.CallOption) (*GetCanteenHeadCountReply, error) {
	out := new(GetCanteenHeadCountReply)
	err := c.cc.Invoke(ctx, CanteenService_GetCanteenHeadCount_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canteenServiceClient) ListCanteenRatings(ctx context.Context, in *ListCanteenRatingsRequest, opts ...grpc.CallOption) (*ListCanteenRatingsReply, error) {
	out := new(ListCanteenRatingsReply)
	err := c.cc.Invoke(ctx, CanteenService_ListCanteenRatings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canteenServiceClient) GetDishRatings(ctx context.Context, in *GetDishRatingsRequest, opts ...grpc.CallOption) (*GetDishRatingsReply, error) {
	out := new(GetDishRatingsReply)
	err := c.cc.Invoke(ctx, CanteenService_GetDishRatings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canteenServiceClient) CreateCanteenRating(ctx context.Context, in *CreateCanteenRatingRequest, opts ...grpc.CallOption) (*CreateCanteenRatingReply, error) {
	out := new(CreateCanteenRatingReply)
	err := c.cc.Invoke(ctx, CanteenService_CreateCanteenRating_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canteenServiceClient) CreateDishRating(ctx context.Context, in *CreateDishRatingRequest, opts ...grpc.CallOption) (*CreateDishRatingReply, error) {
	out := new(CreateDishRatingReply)
	err := c.cc.Invoke(ctx, CanteenService_CreateDishRating_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canteenServiceClient) ListAvailableDishTags(ctx context.Context, in *ListAvailableDishTagsRequest, opts ...grpc.CallOption) (*ListAvailableDishTagsReply, error) {
	out := new(ListAvailableDishTagsReply)
	err := c.cc.Invoke(ctx, CanteenService_ListAvailableDishTags_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canteenServiceClient) ListNameTags(ctx context.Context, in *ListNameTagsRequest, opts ...grpc.CallOption) (*ListNameTagsReply, error) {
	out := new(ListNameTagsReply)
	err := c.cc.Invoke(ctx, CanteenService_ListNameTags_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canteenServiceClient) ListAvailableCanteenTags(ctx context.Context, in *ListAvailableCanteenTagsRequest, opts ...grpc.CallOption) (*ListAvailableCanteenTagsReply, error) {
	out := new(ListAvailableCanteenTagsReply)
	err := c.cc.Invoke(ctx, CanteenService_ListAvailableCanteenTags_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canteenServiceClient) ListCanteens(ctx context.Context, in *ListCanteensRequest, opts ...grpc.CallOption) (*ListCanteensReply, error) {
	out := new(ListCanteensReply)
	err := c.cc.Invoke(ctx, CanteenService_ListCanteens_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *canteenServiceClient) ListDishes(ctx context.Context, in *ListDishesRequest, opts ...grpc.CallOption) (*ListDishesReply, error) {
	out := new(ListDishesReply)
	err := c.cc.Invoke(ctx, CanteenService_ListDishes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CanteenServiceServer is the server API for CanteenService service.
// All implementations must embed UnimplementedCanteenServiceServer
// for forward compatibility
type CanteenServiceServer interface {
	GetCanteenHeadCount(context.Context, *GetCanteenHeadCountRequest) (*GetCanteenHeadCountReply, error)
	// This endpoint retrieves Canteen Ratings from the Backend.
	ListCanteenRatings(context.Context, *ListCanteenRatingsRequest) (*ListCanteenRatingsReply, error)
	GetDishRatings(context.Context, *GetDishRatingsRequest) (*GetDishRatingsReply, error)
	CreateCanteenRating(context.Context, *CreateCanteenRatingRequest) (*CreateCanteenRatingReply, error)
	CreateDishRating(context.Context, *CreateDishRatingRequest) (*CreateDishRatingReply, error)
	ListAvailableDishTags(context.Context, *ListAvailableDishTagsRequest) (*ListAvailableDishTagsReply, error)
	ListNameTags(context.Context, *ListNameTagsRequest) (*ListNameTagsReply, error)
	ListAvailableCanteenTags(context.Context, *ListAvailableCanteenTagsRequest) (*ListAvailableCanteenTagsReply, error)
	ListCanteens(context.Context, *ListCanteensRequest) (*ListCanteensReply, error)
	ListDishes(context.Context, *ListDishesRequest) (*ListDishesReply, error)
	mustEmbedUnimplementedCanteenServiceServer()
}

// UnimplementedCanteenServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCanteenServiceServer struct {
}

func (UnimplementedCanteenServiceServer) GetCanteenHeadCount(context.Context, *GetCanteenHeadCountRequest) (*GetCanteenHeadCountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCanteenHeadCount not implemented")
}
func (UnimplementedCanteenServiceServer) ListCanteenRatings(context.Context, *ListCanteenRatingsRequest) (*ListCanteenRatingsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCanteenRatings not implemented")
}
func (UnimplementedCanteenServiceServer) GetDishRatings(context.Context, *GetDishRatingsRequest) (*GetDishRatingsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDishRatings not implemented")
}
func (UnimplementedCanteenServiceServer) CreateCanteenRating(context.Context, *CreateCanteenRatingRequest) (*CreateCanteenRatingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCanteenRating not implemented")
}
func (UnimplementedCanteenServiceServer) CreateDishRating(context.Context, *CreateDishRatingRequest) (*CreateDishRatingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDishRating not implemented")
}
func (UnimplementedCanteenServiceServer) ListAvailableDishTags(context.Context, *ListAvailableDishTagsRequest) (*ListAvailableDishTagsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAvailableDishTags not implemented")
}
func (UnimplementedCanteenServiceServer) ListNameTags(context.Context, *ListNameTagsRequest) (*ListNameTagsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNameTags not implemented")
}
func (UnimplementedCanteenServiceServer) ListAvailableCanteenTags(context.Context, *ListAvailableCanteenTagsRequest) (*ListAvailableCanteenTagsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAvailableCanteenTags not implemented")
}
func (UnimplementedCanteenServiceServer) ListCanteens(context.Context, *ListCanteensRequest) (*ListCanteensReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCanteens not implemented")
}
func (UnimplementedCanteenServiceServer) ListDishes(context.Context, *ListDishesRequest) (*ListDishesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDishes not implemented")
}
func (UnimplementedCanteenServiceServer) mustEmbedUnimplementedCanteenServiceServer() {}

// UnsafeCanteenServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CanteenServiceServer will
// result in compilation errors.
type UnsafeCanteenServiceServer interface {
	mustEmbedUnimplementedCanteenServiceServer()
}

func RegisterCanteenServiceServer(s grpc.ServiceRegistrar, srv CanteenServiceServer) {
	s.RegisterService(&CanteenService_ServiceDesc, srv)
}

func _CanteenService_GetCanteenHeadCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCanteenHeadCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanteenServiceServer).GetCanteenHeadCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanteenService_GetCanteenHeadCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanteenServiceServer).GetCanteenHeadCount(ctx, req.(*GetCanteenHeadCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanteenService_ListCanteenRatings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCanteenRatingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanteenServiceServer).ListCanteenRatings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanteenService_ListCanteenRatings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanteenServiceServer).ListCanteenRatings(ctx, req.(*ListCanteenRatingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanteenService_GetDishRatings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDishRatingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanteenServiceServer).GetDishRatings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanteenService_GetDishRatings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanteenServiceServer).GetDishRatings(ctx, req.(*GetDishRatingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanteenService_CreateCanteenRating_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCanteenRatingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanteenServiceServer).CreateCanteenRating(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanteenService_CreateCanteenRating_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanteenServiceServer).CreateCanteenRating(ctx, req.(*CreateCanteenRatingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanteenService_CreateDishRating_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDishRatingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanteenServiceServer).CreateDishRating(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanteenService_CreateDishRating_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanteenServiceServer).CreateDishRating(ctx, req.(*CreateDishRatingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanteenService_ListAvailableDishTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAvailableDishTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanteenServiceServer).ListAvailableDishTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanteenService_ListAvailableDishTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanteenServiceServer).ListAvailableDishTags(ctx, req.(*ListAvailableDishTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanteenService_ListNameTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNameTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanteenServiceServer).ListNameTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanteenService_ListNameTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanteenServiceServer).ListNameTags(ctx, req.(*ListNameTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanteenService_ListAvailableCanteenTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAvailableCanteenTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanteenServiceServer).ListAvailableCanteenTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanteenService_ListAvailableCanteenTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanteenServiceServer).ListAvailableCanteenTags(ctx, req.(*ListAvailableCanteenTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanteenService_ListCanteens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCanteensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanteenServiceServer).ListCanteens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanteenService_ListCanteens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanteenServiceServer).ListCanteens(ctx, req.(*ListCanteensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CanteenService_ListDishes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDishesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CanteenServiceServer).ListDishes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CanteenService_ListDishes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CanteenServiceServer).ListDishes(ctx, req.(*ListDishesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CanteenService_ServiceDesc is the grpc.ServiceDesc for CanteenService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CanteenService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.CanteenService",
	HandlerType: (*CanteenServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCanteenHeadCount",
			Handler:    _CanteenService_GetCanteenHeadCount_Handler,
		},
		{
			MethodName: "ListCanteenRatings",
			Handler:    _CanteenService_ListCanteenRatings_Handler,
		},
		{
			MethodName: "GetDishRatings",
			Handler:    _CanteenService_GetDishRatings_Handler,
		},
		{
			MethodName: "CreateCanteenRating",
			Handler:    _CanteenService_CreateCanteenRating_Handler,
		},
		{
			MethodName: "CreateDishRating",
			Handler:    _CanteenService_CreateDishRating_Handler,
		},
		{
			MethodName: "ListAvailableDishTags",
			Handler:    _CanteenService_ListAvailableDishTags_Handler,
		},
		{
			MethodName: "ListNameTags",
			Handler:    _CanteenService_ListNameTags_Handler,
		},
		{
			MethodName: "ListAvailableCanteenTags",
			Handler:    _CanteenService_ListAvailableCanteenTags_Handler,
		},
		{
			MethodName: "ListCanteens",
			Handler:    _CanteenService_ListCanteens_Handler,
		},
		{
			MethodName: "ListDishes",
			Handler:    _CanteenService_ListDishes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tumdev/campus_backend.proto",
}

const (
	NotificationService_GetUploadStatus_FullMethodName          = "/api.NotificationService/GetUploadStatus"
	NotificationService_GetNotification_FullMethodName          = "/api.NotificationService/GetNotification"
	NotificationService_GetNotificationConfirm_FullMethodName   = "/api.NotificationService/GetNotificationConfirm"
	NotificationService_GetMember_FullMethodName                = "/api.NotificationService/GetMember"
	NotificationService_IOSDeviceRequestResponse_FullMethodName = "/api.NotificationService/IOSDeviceRequestResponse"
	NotificationService_CreateDevice_FullMethodName             = "/api.NotificationService/CreateDevice"
	NotificationService_DeleteDevice_FullMethodName             = "/api.NotificationService/DeleteDevice"
)

// NotificationServiceClient is the client API for NotificationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationServiceClient interface {
	GetUploadStatus(ctx context.Context, in *GetUploadStatusRequest, opts ...grpc.CallOption) (*GetUploadStatusReply, error)
	GetNotification(ctx context.Context, in *GetNotificationRequest, opts ...grpc.CallOption) (*GetNotificationReply, error)
	GetNotificationConfirm(ctx context.Context, in *GetNotificationConfirmRequest, opts ...grpc.CallOption) (*GetNotificationConfirmReply, error)
	GetMember(ctx context.Context, in *GetMemberRequest, opts ...grpc.CallOption) (*GetMemberReply, error)
	// Endpoint for the iOS app to respond to background notifications requests
	IOSDeviceRequestResponse(ctx context.Context, in *IOSDeviceRequestResponseRequest, opts ...grpc.CallOption) (*IOSDeviceRequestResponseReply, error)
	// Create an device (Android/iOS/Windows) for push notifications
	CreateDevice(ctx context.Context, in *CreateDeviceRequest, opts ...grpc.CallOption) (*CreateDeviceReply, error)
	// Delete a device from push notifications
	DeleteDevice(ctx context.Context, in *DeleteDeviceRequest, opts ...grpc.CallOption) (*DeleteDeviceReply, error)
}

type notificationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationServiceClient(cc grpc.ClientConnInterface) NotificationServiceClient {
	return &notificationServiceClient{cc}
}

func (c *notificationServiceClient) GetUploadStatus(ctx context.Context, in *GetUploadStatusRequest, opts ...grpc.CallOption) (*GetUploadStatusReply, error) {
	out := new(GetUploadStatusReply)
	err := c.cc.Invoke(ctx, NotificationService_GetUploadStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) GetNotification(ctx context.Context, in *GetNotificationRequest, opts ...grpc.CallOption) (*GetNotificationReply, error) {
	out := new(GetNotificationReply)
	err := c.cc.Invoke(ctx, NotificationService_GetNotification_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) GetNotificationConfirm(ctx context.Context, in *GetNotificationConfirmRequest, opts ...grpc.CallOption) (*GetNotificationConfirmReply, error) {
	out := new(GetNotificationConfirmReply)
	err := c.cc.Invoke(ctx, NotificationService_GetNotificationConfirm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) GetMember(ctx context.Context, in *GetMemberRequest, opts ...grpc.CallOption) (*GetMemberReply, error) {
	out := new(GetMemberReply)
	err := c.cc.Invoke(ctx, NotificationService_GetMember_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) IOSDeviceRequestResponse(ctx context.Context, in *IOSDeviceRequestResponseRequest, opts ...grpc.CallOption) (*IOSDeviceRequestResponseReply, error) {
	out := new(IOSDeviceRequestResponseReply)
	err := c.cc.Invoke(ctx, NotificationService_IOSDeviceRequestResponse_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) CreateDevice(ctx context.Context, in *CreateDeviceRequest, opts ...grpc.CallOption) (*CreateDeviceReply, error) {
	out := new(CreateDeviceReply)
	err := c.cc.Invoke(ctx, NotificationService_CreateDevice_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) DeleteDevice(ctx context.Context, in *DeleteDeviceRequest, opts ...grpc.CallOption) (*DeleteDeviceReply, error) {
	out := new(DeleteDeviceReply)
	err := c.cc.Invoke(ctx, NotificationService_DeleteDevice_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationServiceServer is the server API for NotificationService service.
// All implementations must embed UnimplementedNotificationServiceServer
// for forward compatibility
type NotificationServiceServer interface {
	GetUploadStatus(context.Context, *GetUploadStatusRequest) (*GetUploadStatusReply, error)
	GetNotification(context.Context, *GetNotificationRequest) (*GetNotificationReply, error)
	GetNotificationConfirm(context.Context, *GetNotificationConfirmRequest) (*GetNotificationConfirmReply, error)
	GetMember(context.Context, *GetMemberRequest) (*GetMemberReply, error)
	// Endpoint for the iOS app to respond to background notifications requests
	IOSDeviceRequestResponse(context.Context, *IOSDeviceRequestResponseRequest) (*IOSDeviceRequestResponseReply, error)
	// Create an device (Android/iOS/Windows) for push notifications
	CreateDevice(context.Context, *CreateDeviceRequest) (*CreateDeviceReply, error)
	// Delete a device from push notifications
	DeleteDevice(context.Context, *DeleteDeviceRequest) (*DeleteDeviceReply, error)
	mustEmbedUnimplementedNotificationServiceServer()
}

// UnimplementedNotificationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNotificationServiceServer struct {
}

func (UnimplementedNotificationServiceServer) GetUploadStatus(context.Context, *GetUploadStatusRequest) (*GetUploadStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUploadStatus not implemented")
}
func (UnimplementedNotificationServiceServer) GetNotification(context.Context, *GetNotificationRequest) (*GetNotificationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotification not implemented")
}
func (UnimplementedNotificationServiceServer) GetNotificationConfirm(context.Context, *GetNotificationConfirmRequest) (*GetNotificationConfirmReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotificationConfirm not implemented")
}
func (UnimplementedNotificationServiceServer) GetMember(context.Context, *GetMemberRequest) (*GetMemberReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMember not implemented")
}
func (UnimplementedNotificationServiceServer) IOSDeviceRequestResponse(context.Context, *IOSDeviceRequestResponseRequest) (*IOSDeviceRequestResponseReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IOSDeviceRequestResponse not implemented")
}
func (UnimplementedNotificationServiceServer) CreateDevice(context.Context, *CreateDeviceRequest) (*CreateDeviceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDevice not implemented")
}
func (UnimplementedNotificationServiceServer) DeleteDevice(context.Context, *DeleteDeviceRequest) (*DeleteDeviceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDevice not implemented")
}
func (UnimplementedNotificationServiceServer) mustEmbedUnimplementedNotificationServiceServer() {}

// UnsafeNotificationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationServiceServer will
// result in compilation errors.
type UnsafeNotificationServiceServer interface {
	mustEmbedUnimplementedNotificationServiceServer()
}

func RegisterNotificationServiceServer(s grpc.ServiceRegistrar, srv NotificationServiceServer) {
	s.RegisterService(&NotificationService_ServiceDesc, srv)
}

func _NotificationService_GetUploadStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUploadStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).GetUploadStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_GetUploadStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).GetUploadStatus(ctx, req.(*GetUploadStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_GetNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).GetNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_GetNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).GetNotification(ctx, req.(*GetNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_GetNotificationConfirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNotificationConfirmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).GetNotificationConfirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_GetNotificationConfirm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).GetNotificationConfirm(ctx, req.(*GetNotificationConfirmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_GetMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).GetMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_GetMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).GetMember(ctx, req.(*GetMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_IOSDeviceRequestResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IOSDeviceRequestResponseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).IOSDeviceRequestResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_IOSDeviceRequestResponse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).IOSDeviceRequestResponse(ctx, req.(*IOSDeviceRequestResponseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_CreateDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).CreateDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_CreateDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).CreateDevice(ctx, req.(*CreateDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_DeleteDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).DeleteDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_DeleteDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).DeleteDevice(ctx, req.(*DeleteDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NotificationService_ServiceDesc is the grpc.ServiceDesc for NotificationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NotificationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.NotificationService",
	HandlerType: (*NotificationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUploadStatus",
			Handler:    _NotificationService_GetUploadStatus_Handler,
		},
		{
			MethodName: "GetNotification",
			Handler:    _NotificationService_GetNotification_Handler,
		},
		{
			MethodName: "GetNotificationConfirm",
			Handler:    _NotificationService_GetNotificationConfirm_Handler,
		},
		{
			MethodName: "GetMember",
			Handler:    _NotificationService_GetMember_Handler,
		},
		{
			MethodName: "IOSDeviceRequestResponse",
			Handler:    _NotificationService_IOSDeviceRequestResponse_Handler,
		},
		{
			MethodName: "CreateDevice",
			Handler:    _NotificationService_CreateDevice_Handler,
		},
		{
			MethodName: "DeleteDevice",
			Handler:    _NotificationService_DeleteDevice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tumdev/campus_backend.proto",
}

const (
	LegacyService_ListResponsiblePerson_FullMethodName = "/api.LegacyService/ListResponsiblePerson"
	LegacyService_ListMoreInformation_FullMethodName   = "/api.LegacyService/ListMoreInformation"
	LegacyService_ListOpeningTimes_FullMethodName      = "/api.LegacyService/ListOpeningTimes"
)

// LegacyServiceClient is the client API for LegacyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LegacyServiceClient interface {
	// deprecated as this should be handled by the navigatum instead
	ListResponsiblePerson(ctx context.Context, in *ListResponsiblePersonRequest, opts ...grpc.CallOption) (*ListResponsiblePersonReply, error)
	// deprecated as this should be handled by the navigatum instead
	ListMoreInformation(ctx context.Context, in *ListMoreInformationRequest, opts ...grpc.CallOption) (*ListMoreInformationReply, error)
	// deprecated as this should be handled by the navigatum instead
	ListOpeningTimes(ctx context.Context, in *ListOpeningTimesRequest, opts ...grpc.CallOption) (*ListOpeningTimesReply, error)
}

type legacyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLegacyServiceClient(cc grpc.ClientConnInterface) LegacyServiceClient {
	return &legacyServiceClient{cc}
}

func (c *legacyServiceClient) ListResponsiblePerson(ctx context.Context, in *ListResponsiblePersonRequest, opts ...grpc.CallOption) (*ListResponsiblePersonReply, error) {
	out := new(ListResponsiblePersonReply)
	err := c.cc.Invoke(ctx, LegacyService_ListResponsiblePerson_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *legacyServiceClient) ListMoreInformation(ctx context.Context, in *ListMoreInformationRequest, opts ...grpc.CallOption) (*ListMoreInformationReply, error) {
	out := new(ListMoreInformationReply)
	err := c.cc.Invoke(ctx, LegacyService_ListMoreInformation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *legacyServiceClient) ListOpeningTimes(ctx context.Context, in *ListOpeningTimesRequest, opts ...grpc.CallOption) (*ListOpeningTimesReply, error) {
	out := new(ListOpeningTimesReply)
	err := c.cc.Invoke(ctx, LegacyService_ListOpeningTimes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LegacyServiceServer is the server API for LegacyService service.
// All implementations must embed UnimplementedLegacyServiceServer
// for forward compatibility
type LegacyServiceServer interface {
	// deprecated as this should be handled by the navigatum instead
	ListResponsiblePerson(context.Context, *ListResponsiblePersonRequest) (*ListResponsiblePersonReply, error)
	// deprecated as this should be handled by the navigatum instead
	ListMoreInformation(context.Context, *ListMoreInformationRequest) (*ListMoreInformationReply, error)
	// deprecated as this should be handled by the navigatum instead
	ListOpeningTimes(context.Context, *ListOpeningTimesRequest) (*ListOpeningTimesReply, error)
	mustEmbedUnimplementedLegacyServiceServer()
}

// UnimplementedLegacyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLegacyServiceServer struct {
}

func (UnimplementedLegacyServiceServer) ListResponsiblePerson(context.Context, *ListResponsiblePersonRequest) (*ListResponsiblePersonReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListResponsiblePerson not implemented")
}
func (UnimplementedLegacyServiceServer) ListMoreInformation(context.Context, *ListMoreInformationRequest) (*ListMoreInformationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMoreInformation not implemented")
}
func (UnimplementedLegacyServiceServer) ListOpeningTimes(context.Context, *ListOpeningTimesRequest) (*ListOpeningTimesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOpeningTimes not implemented")
}
func (UnimplementedLegacyServiceServer) mustEmbedUnimplementedLegacyServiceServer() {}

// UnsafeLegacyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LegacyServiceServer will
// result in compilation errors.
type UnsafeLegacyServiceServer interface {
	mustEmbedUnimplementedLegacyServiceServer()
}

func RegisterLegacyServiceServer(s grpc.ServiceRegistrar, srv LegacyServiceServer) {
	s.RegisterService(&LegacyService_ServiceDesc, srv)
}

func _LegacyService_ListResponsiblePerson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListResponsiblePersonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LegacyServiceServer).ListResponsiblePerson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LegacyService_ListResponsiblePerson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LegacyServiceServer).ListResponsiblePerson(ctx, req.(*ListResponsiblePersonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LegacyService_ListMoreInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMoreInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LegacyServiceServer).ListMoreInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LegacyService_ListMoreInformation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LegacyServiceServer).ListMoreInformation(ctx, req.(*ListMoreInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LegacyService_ListOpeningTimes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOpeningTimesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LegacyServiceServer).ListOpeningTimes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LegacyService_ListOpeningTimes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LegacyServiceServer).ListOpeningTimes(ctx, req.(*ListOpeningTimesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LegacyService_ServiceDesc is the grpc.ServiceDesc for LegacyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LegacyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.LegacyService",
	HandlerType: (*LegacyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListResponsiblePerson",
			Handler:    _LegacyService_ListResponsiblePerson_Handler,
		},
		{
			MethodName: "ListMoreInformation",
			Handler:    _LegacyService_ListMoreInformation_Handler,
		},
		{
			MethodName: "ListOpeningTimes",
			Handler:    _LegacyService_ListOpeningTimes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tumdev/campus_backend.proto",
}
